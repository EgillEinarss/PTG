/*
	PTG is a parsing table generator for common grammars used in academics.
    Copyright (C) 2013  Egill Búi Einarsson, ebe10@hi.is

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/	

import java.util.ArrayList;
import java.util.TreeSet;
import java.util.HashMap;

public class Grammar{
    public String prefix;       // Prefix of all output files.
    public String newStart;     // A variable, not used in the grammars input,
                                //  that is only used in the production newStart -> start
    public String start;        // The start variable of the input grammar, defaults to the
                                //  first string(space-seperated) in the input grammar.
    public String empty;        // The symbol used to define an empty string, default to <e>
    public String end;          // The symbol used to define the end of an input string, that
                                //  is a string that is supposedly generated by the input grammar,
                                //  defaults to $
    public String seperator;    // The second string(space-seperated) in the input grammar, that
                                //  is start seperator [...]. Not used to any affect.
    public TreeSet<String> V;   // Set of all symbols to the left of a seperator. Some methods add
                                //  and remove newStart.
    public TreeSet<String> T;   // Set of all symbols in the input grammar excluding the seperator
                                //  and any symbols in V but including end.
    public HashMap<String, TreeSet<String[]>> rules;
                                // A mapping of Symbols to a set of the right sides of their
                                //  productions. Includes newStart -> start.
                                
    private boolean noConflict; 
    
    /*  Constructor
    Usage:  g = new Grammar(file, prefix, start, empty, end)
    Pre:    file is the name of a filename containing an input grammar.
    Post:   g is fully ready to generate LaTeX or HTML tables or Graphviz statemachines
            using it's findX methods, output files start with the set prefix.
    */
    public Grammar(String file, String prefix, String start, String empty, String end){
        this.noConflict = true;
        this.prefix = prefix;
        this.V = new TreeSet<String>();
        this.T = new TreeSet<String>();
        this.rules = new HashMap<String, TreeSet<String[]>>();
        ArrayList<String[]> parseList = new ArrayList<String[]>();
        try{ // Read data from provided file
            java.io.BufferedReader br = new java.io.BufferedReader(new java.io.FileReader(file));
            String line;
            while( (line = br.readLine()) != null && !line.equals("")){
                parseList.add(prepareLine(line));
            }   // parseList now contains all rules parsed from the input grammar
            br.close();
        } catch(java.io.IOException e){
            System.out.println("Invalid fileName.\n");
            System.exit(3);
        }
        this.empty = empty;
        this.end = end;
        if(start.equals("")){
            //No start provided, find default
            start = parseList.get(0)[0];
        }
        this.start = start;
        this.seperator = parseList.get(0)[1];
        for(String[] production : parseList){
            add(production[0]); // Add variable if missing
            add(production);    // Add production connected to the variable and all symbols to T
        }
        for(String v : V)
            T.remove(v);
        this.T.remove(empty);   
        this.T.add(end);
        // Below: Find an acceptable newStart, that is start concatenated with one or more '
        //  and add the rule newStart -> start.
        this.newStart = this.start + "'";
        while(this.V.contains(newStart) || this.T.contains(this.newStart)) this.newStart += "'";
        String[] startFix = new String[1];
        startFix[0] = this.start;
        TreeSet<String[]> startTree = new TreeSet<String[]>(new StringArrayComparator());
        startTree.add(startFix);
        this.rules.put(newStart, startTree);
    }

    /*  Used for preparation
    Usage:  rule = prepareLine(line)
    Pre:    line is a whitespace seperated grammar production, that is v -> r
            where v is a variable and r is a whitespace seperated result
    Post:   rule is [v, r1, r2, ..., rn], where r contains n+1 elements
    */
    private String[] prepareLine(String line){
        line.replaceAll("\t", " ");
        while(line.indexOf("  ") != -1) line = line.replaceFirst("  ", " ");
        String[] segments = line.split(" ");
        return segments;
    }

    /*  Used for preparation
    Usage:  add(label)
    Pre:    label is a variable from the input grammar
    Post:   If V did not contain label, then V now contains label
            and rules.get(label) is a set ready to recieve new productions.
    */
    private void add(String label){
        V.add(label);
        if(!rules.containsKey(label)) rules.put(label, new TreeSet<String[]>(new StringArrayComparator()));
    }
    
    /*  Used for preparation
    Usage:  add(r)
    Pre:    r.length > 1
    Post:   The set rules.get(r[0]) contains the result r[1..n]
    */
    private void add(String[] r){
        String left = r[0];
        String[] right = new String[r.length-2];
        for(int i = 0; i < right.length; i++){
            right[i] = r[i+2];
            T.add(right[i]);
        }
        rules.get(left).add(right);
    }
    
    public void find(PTGoptions opt){
        StateMachine M = null;
        if(opt.title.equals("FIRST")){
            tableCreator(new firstCO(), opt);
        }
        else if(opt.title.equals("FOLLOW")){
            tableCreator(new followCO(), opt);
        }
        else if(opt.title.equals("LL1")){
            tableCreator(new LL1CO(), opt);
        }
        else if(opt.title.equals("LR0M")){
            if(opt.html) LR(new Action(newStart, start, 0, end, true, empty),
                            new ActionSetComparator(), opt.stateSize).makeGz(opt.outname + opt.title + ".gz", V, empty, opt.LR);
            if(opt.latex) LR(new Action(newStart, start, 0, end, false, empty),
                            new ActionSetComparator(), opt.stateSize).makeTikz(opt.outname + opt.title + ".tex", V, empty, opt.LR);
        }
        else if(opt.title.equals("SLR1")){
            M = LR(new Action(newStart, start, 0, end, true, empty), new ActionSetComparator(), 2);
            opt.addStates(M.size());
            tableCreator(new SLR1CO(M), opt);
        }
        else if(opt.title.equals("LR1")){
            M = LR(new ExtendedAction(newStart, start, 0, end, true, empty), new ExtendedActionSetComparator(), 2);
            opt.addStates(M.size());
            tableCreator(new LR1CO(M), opt);
        }
        else if(opt.title.equals("LR1M")){
            if(opt.html) LR(new ExtendedAction(newStart, start, 0, end, true, empty),
                                new ExtendedActionSetComparator(), opt.stateSize).makeGz(opt.outname + opt.title + ".gz", V, empty, opt.LR);
            if(opt.latex) LR(new ExtendedAction(newStart, start, 0, end, false, empty),
                                new ExtendedActionSetComparator(), opt.stateSize).makeTikz(opt.outname + opt.title + ".tex", V, empty, opt.LR);
        }
        else if(opt.title.equals("LALR1")){
            M = LR(new ExtendedAction(newStart, start, 0, end, true, empty), new ActionSetComparator(),2);
            opt.addStates(M.size());
            tableCreator(new LALR1CO(M), opt);
        }
        else if(opt.title.equals("LALR1M")){
            if(opt.html) LR(new ExtendedAction(newStart, start, 0, end, true, empty),
                                new ActionSetComparator(), opt.stateSize).makeGz(opt.outname + opt.title + ".gz", V, empty, opt.LR);
            if(opt.latex) LR(new ExtendedAction(newStart, start, 0, end, false, empty),
                                new ActionSetComparator(), opt.stateSize).makeTikz(opt.outname + opt.title + ".tex", V, empty, opt.LR);
        }
    }
    
    /*public void find(PTGoptions opt){
        callObject co = null;
        StateMachine MH = null;
        StateMachine ML = null;
        if(opt.title.equals("FIRST")){
            co = new firstCO();
        }
        else if(opt.title.equals("FOLLOW")){
            co = new followCO();
        }
        else if(opt.title.equals("LL1")){
            co = new LL1CO();
        }
        else if(opt.title.equals("LR0") || opt.title.equals("SLR1")){
            MH = LR(new Action(newStart, start, 0, end, true), new ActionSetComparator());
            ML = LR(new Action(newStart, start, 0, end, false), new ActionSetComparator());
            co = new SLR1CO(M);
            opt.addStates(M.size());
        }
        else if(opt.title.equals("LALR1")){
            MH = LR(new ExtendedAction(newStart, start, 0, end, true), new ActionSetComparator());;
            ML = LR(new ExtendedAction(newStart, start, 0, end, false), new ActionSetComparator());;
            co = new LALR1CO(M);
            opt.addStates(M.size());
        }
        else if(opt.title.equals("LR1")){
            MH = LR(new ExtendedAction(newStart, start, 0, end, true), new ExtendedActionSetComparator());;
            ML = LR(new ExtendedAction(newStart, start, 0, end, false), new ExtendedActionSetComparator());;
            co = new LR1CO(M);
            opt.addStates(M.size());
        }
        
        if(opt.machine){
            if(opt.html) MH.makeGz(opt.outname + ".gz", V, empty);
            if(opt.latex) ML.makeTikz(opt.outname + ".gz", V, empty);
        }
        if(opt.html || opt.latex) tableCreator(co, opt);
    }*/
    
    /*  Find method !!!!
    Usage:  g.findFirst(h)
    Pre:    g is a constructed grammar
    Post:   Prints a table with only one column marked FIRST(X), rows labelled v, where v is
            every variable in g.V, and the values are the first(v).
            If h is true then the file is prefix + first.html and the table is a tbody
            otherwise the file is prefix + first.tex and the table is a tabular.
    */
    /*public void findFirst(boolean html){
        int i = 0;
        String[] rows = new String[V.size()];
        for(String s : V) rows[i++] = s;
        String[] columns = new String[1];
        columns[0] = "FIRST(X)";
        if(html) htmlTC(new firstCO(), "first", "X", rows, columns);
        else LaTeXTC(new firstCO(), "first", "X", rows, columns, -1);
    }
    
    /*  Find method !!!
    Usage:  g.findFollow(h)
    Pre:    g is a constructed grammar
    Post:   Prints a table with only one column marked FOLLOW(X), rows labelled v, where v is
            every variable in g.V, and the values are the follow(v).
            If h is true then the file is prefix + follow.html and the table is a tbody
            otherwise the file is prefix + follow.tex and the table is a tabular.
    */
    /*public void findFollow(boolean html){
        int i = 0;
        String[] rows = new String[V.size()];
        for(String s : V) rows[i++] = s;
        String[] columns = new String[1];
        columns[0] = "FOLLOW(X)";
        if(html) htmlTC(new followCO(), "follow", "X", rows, columns);
        else LaTeXTC(new followCO(), "follow", "X", rows, columns, -1);
    }
    
    /*  Find method !!!!
    Usage:  g.findLL1(h)
    Pre:    g is a constructed grammar
    Post:   Prints a table with columns marked for each t in g.T(including end),
            rows labelled v, where v is every variable in g.V, and each values is the
            action to take when parsing for va
            If h is true then the file is prefix + first.html and the table is a tbody
            otherwise the file is prefix + first.tex and the table is a tabular.
    */
    /*public void findLL1(boolean html){
        int i = 0;
        String[] rows = new String[V.size()];
        for(String s : V) rows[i++] = s;
        /*i = 0;
        String[] columns = new String[T.size()];
        for(String s : T) columns[i++] = s;
    
    /*public void findLR0(String name){
        StateMachine M = LR(new Action(newStart, start, 0, end), new ActionSetComparator());
        M.makeGz(name + ".gz", V, empty);
    }
    
    public void findSLR1(boolean html){
        StateMachine M = LR(new Action(newStart, start, 0, end), new ActionSetComparator());
        int i;
        String[] rows = new String[M.size()];
        if(html) for(i = 0; i < M.size(); i++) rows[i] = "I<sub>" + i + "</sub>";
        else for(i = 0; i < M.size(); i++) rows[i] = "I$_{" + i + "}$";
        i = 0;
        String[] columns = new String[T.size() + V.size()];
        for(String s : T) columns[i++] = s;
        for(String s : V) columns[i++] = s;
        if(html) htmlTC(new SLR1CO(M), "SLR1", "X", rows, columns);
        else LaTeXTC(new SLR1CO(M), "SLR1", "X", rows, columns, T.size());
    }

    public void findLR1(String name){
        StateMachine M = LR(new ExtendedAction(newStart, start, 0, end), new ExtendedActionSetComparator());
        M.makeGz(name + ".gz", V, empty);
    }
    
    public void findLALR1(boolean html){
        StateMachine M = LR(new ExtendedAction(newStart, start, 0, end), new ExtendedActionSetComparator());
        int i;
        String[] rows = new String[M.size()];
        if(html) for(i = 0; i < M.size(); i++) rows[i] = "I<sub>" + i + "</sub>";
        else for(i = 0; i < M.size(); i++) rows[i] = "I$_{" + i + "}$";
        i = 0;
        String[] columns = new String[T.size() + V.size()];
        for(String s : T) columns[i++] = s;
        for(String s : V) columns[i++] = s;
        if(html) htmlTC(new LALR1CO(M), "LALR1", "X", rows, columns);
        else LaTeXTC(new LALR1CO(M), "LALR1", "X", rows, columns, T.size());
    }
    */
    /*  variable attribute
    Usage:  b = nullable(X)
    Post:   b is true if rules.get(X) contains a production that is just <e>, false otherwise.
    */
    private boolean nullable(String X){
        for(String[] Y : rules.get(X))
            if(Y[0].equals(empty)) return true;
        return false;
    }
    
    private TreeSet<String> first(String X){
        TreeSet<String> first = new TreeSet<String>();
        TreeSet<String> checked = new TreeSet<String>();
        checked.add(X);
        if(V.contains(X)){
            for(String[] Y : rules.get(X)){
                first.addAll(first(Y, first, checked));
            }
        } else
            first.add(X);
        return first;
    }
    
    private TreeSet<String> first(String X, TreeSet<String> first, TreeSet<String> checked){
        if(checked.contains(X))
            return first;
        checked.add(X);
        if(V.contains(X)){
            for(String[] Y : rules.get(X)){
                first.addAll(first(Y, first, checked));
            }
        } else
            first.add(X);
        return first;
    }
    
    private TreeSet<String> first(String[] Y){
        TreeSet<String> first = new TreeSet<String>();
        if(Y.length == 0){
            first.add(empty);
            return first;
        }
        for(int i = 0; i < Y.length; i++){
            first.addAll(first(Y[i]));
            if(!(V.contains(Y[i]) && nullable(Y[i])) )
                break;
        }
        return first;
    }
    
    private TreeSet<String> first(String[] Y, TreeSet<String> first, TreeSet<String> checked){
       for(int i = 0; i < Y.length; i++){
            first.addAll(first(Y[i], first, checked));
            if(!(V.contains(Y[i]) && nullable(Y[i])) )
                break;
        }
        return first;
    }
    
    private TreeSet<String> follow(String B){
        TreeSet<String> follow = new TreeSet<String>();
        if(B.equals(newStart)) follow.add(end);
        if(B.equals(start)) follow.add(end);
        for(String A : V)
            for(String[] Y : rules.get(A)){
                for(int a = 0; a < Y.length;){
                    if(Y[a++].equals(B)){
                        String[] b = new String[Y.length-a];
                        for(int i = 0; i < b.length; i++)
                            b[i] = Y[a + i];
                        TreeSet<String> fBeta = first(b);
                        follow.addAll(fBeta);
                        if(fBeta.contains(empty) && !A.equals(B)) follow.addAll(follow(A));
                    }
                }
            }
        follow.remove(empty);
        return follow;
    }
    
    private TreeSet<String[]> LL1(String A, String b){
        TreeSet<String[]> LL = new TreeSet<String[]>(new StringArrayComparator());
        for(String[] rule : rules.get(A)){
            TreeSet<String> first = first(rule);
            if(first.contains(b)) LL.add(rule);
            if(first.contains(empty) && follow(A).contains(b)) LL.add(rule);
        }
        return LL;
    }
    
    private <E extends Action> TreeSet<E> closure(TreeSet<E> I){
        int oldSize = 0;
        TreeSet<E> closure = new TreeSet<E>(new ActionComparator());
        while(oldSize < I.size()){
            oldSize = I.size();
            for(E a : I)
                if(V.contains(a.next()))
                    for(String[] g : rules.get(a.next()))
                        if(a.follow().equals("")) closure.add((E)a.next(g, ""));
                        else for(String b : T)
                            if(first(a.beta(a.follow())).contains(b)) closure.add((E)a.next(g, b));
            I.addAll(closure);
        }
        return I;
    }
    
    private <T extends Action> TreeSet<T> GOTO(TreeSet<T> I, String X){
        TreeSet<T> g = new TreeSet<T>(new ActionComparator());
        for(T a : I)
            if(a.next().equals(X)) g.add((T)a.advance());
        return closure(g);
    }
    
    private <E extends Action> StateMachine<TreeSet<E>, String> LR(E seed, java.util.Comparator<TreeSet<E>> c, int stateSize){
        V.add(newStart);
        TreeSet<E> I = new TreeSet<E>(new ActionComparator());
        I.add(seed);
        StateMachine<TreeSet<E>, String> M = new StateMachine<TreeSet<E>, String>(closure(I), c, stateSize);
        for(int i = 0; i < M.size(); i++){
            I = M.get(i);
            TreeSet<String> X = new TreeSet<String>();
            for(E a : I)
                X.add(a.next());
            X.remove("");
            X.remove("<e>");
            for(String x : X)
                M.add(i, x, GOTO(I, x));
        }
        V.remove(newStart);
        return M;
    }
    
    public String[] SLR1(StateMachine M, int s, String a){
        String[] o = new String[2];
        o[0] = ""; //HTML
        o[1] = ""; //LaTex
        TreeSet<Action> I = (TreeSet<Action>)(M.get(s));
        if((int)(M.get(s, a)) != -1){
            if(!V.contains(a)){
                o[0] += "shift ";
                o[1] += "shift ";
            }
            o[0] += "I<sub>" + (int)(M.get(s, a)) + "</sub>";
            o[1] += "I$_{" + (int)(M.get(s, a)) + "}$";
        }
        for(Action A : I){
            if(A.completed() && follow(A.left).contains(a)){
                if(!o[0].equals("")){
                    o[0] += "<br>";
                    o[1] += " \\\\ ";
                    if(noConflict){
                        noConflict = false;
                        System.err.println("SLR(1) conflict detected. Could be others.");
                    }
                }
                o[0] += "reduce " + PTG.escapeHtml(A.left, empty) + " &rarr; " + arrayToString(PTG.escapeHtml(A.right, empty));
                o[1] += "reduce " + PTG.escapeLatex(A.left, empty, false) + " $\\rightarrow$ " + arrayToString(PTG.escapeLatex(A.right, empty, false));
            }
        }
        return o;
    }
    
    public String[] LALR1(StateMachine M, int s, String a){
        String[] o = new String[2];
        o[0] = ""; //HTML
        o[1] = ""; //LaTex
        TreeSet<ExtendedAction> I = (TreeSet<ExtendedAction>)(M.get(s));
        if((int)(M.get(s, a)) != -1){
            if(!V.contains(a)){
                o[0] += "shift ";
                o[1] += "shift ";
            }
            o[0] += "I<sub>" + (int)(M.get(s, a)) + "</sub>";
            o[1] += "I$_{" + (int)(M.get(s, a)) + "}$";
        }
        for(Action A : I){
            if(A.completed() && follow(A.left).contains(a)){
                if(!o[0].equals("")){
                    o[0] += "<br>";
                    o[1] += " \\\\ ";
                    if(noConflict){
                        noConflict = false;
                        System.err.println("LALR(1) conflict detected. Could be others.");
                    }
                }
                o[0] += "reduce " + PTG.escapeHtml(A.left, empty) + " &rarr; " + arrayToString(PTG.escapeHtml(A.right,empty));
                o[1] += "reduce " + PTG.escapeLatex(A.left, empty, false) + " $\\rightarrow$ " + arrayToString(PTG.escapeLatex(A.right,empty,false));
            }
        }
        return o;
    }

    public String[] LR1(StateMachine M, int s, String a){
        String[] o = new String[2];
        o[0] = ""; //HTML
        o[1] = ""; //LaTex
        TreeSet<ExtendedAction> I = (TreeSet<ExtendedAction>)(M.get(s));
        if((int)(M.get(s, a)) != -1){
            if(!V.contains(a)){
                o[0] += "shift ";
                o[1] += "shift ";
            }
            o[0] += "I<sub>" + (int)(M.get(s, a)) + "</sub>";
            o[1] += "I$_{" + (int)(M.get(s, a)) + "}$";
        }
        for(Action A : I){
            if(A.completed() && T.contains(A.follow()) && follow(A.left).contains(a)){
                if(!o[0].equals("")){
                    o[0] += "<br>";
                    o[1] += " \\\\ ";
                    if(noConflict){
                        noConflict = false;
                        System.err.println("LR(1) conflict detected. Could be others.");
                    }
                }
                o[0] += "reduce " + PTG.escapeHtml(A.left, empty) + " &rarr; " + arrayToString(PTG.escapeHtml(A.right,empty));
                o[1] += "reduce " + PTG.escapeLatex(A.left, empty, false) + " $\\rightarrow$ " + arrayToString(PTG.escapeLatex(A.right,empty, false));
            }
        }
        return o;
    }

    /*public void LaTeXTC(callObject co, String suffix, String title, String[] rows, String[] columns, int vbreak){
        try{
            java.io.BufferedWriter bw = new java.io.BufferedWriter(new java.io.FileWriter(prefix + suffix + ".tex"));
            if(vbreak == -1)
                bw.write("\\begin{tabular}{|" + repeatString(" c |", columns.length + 1) + "}");
            else
                bw.write("\\begin{tabular}{|" + repeatString(" c |", vbreak + 1) + "|" + repeatString(" c |", columns.length - vbreak) + "}");
            bw.newLine();
            bw.write("  \\hline");
            bw.newLine();
            bw.write("  \\verb#" + title + "#");
            for(String s : columns)
                bw.write(" & \\verb#" + s + "#");
            bw.write(" \\\\ \\hline");
            bw.newLine();
            for(String A : rows){
                if(A.startsWith("I$_{")) bw.write("  " + A);
                else bw.write("  \\verb#" + A + "#");
                for(String b : columns) bw.write(" & " + co.call(A,b,false) );
                bw.write(" \\\\ \\hline");
                bw.newLine();
            }
            bw.write("\\end{tabular}");
            bw.newLine();
            bw.close();
        } catch(java.io.IOException e){
            System.out.println(prefix + suffix + ".tex appears to be locked.\n");
            System.exit(9);
        }
    }
    
    public void htmlTC(callObject co, String suffix, String title, String[] rows, String[] columns){
        try{
            java.io.BufferedWriter bw = new java.io.BufferedWriter(new java.io.FileWriter(prefix + suffix + ".html"));
            bw.write("<table border='1' align='center'>");
            bw.newLine();
            bw.write("  <tbody>");
            bw.newLine();
            bw.write("    <tr align='center'> <td>" + title + "</td>");
            for(String s : columns)
                bw.write(" <td>" + s + "</td>");
            bw.write("</tr>");
            bw.newLine();
            for(String A : rows){
                bw.write("    <tr align='center'> <td>" + A + "</td>");
                for(String b : columns) bw.write(" <td>" + co.call(A,b,true) + "</td>");
                bw.write("</tr>");
                bw.newLine();
            }
            bw.write("  </tbody>");
            bw.newLine();
            bw.write("</table>");
            bw.newLine();
            bw.close();
        } catch(java.io.IOException e){
            System.out.println(prefix + suffix + ".html appears to be locked.\n");
            System.exit(9);
        }
    }
    */
    
    public void tableCreator(callObject co, PTGoptions opt){
        if(opt.latex){
            try{
                java.io.BufferedWriter bw = new java.io.BufferedWriter(new java.io.FileWriter(opt.outname + opt.title + ".tex"));
                if(opt.vbreak == -1)
                    bw.write("\\begin{tabular}{|" + repeatString(" c |", opt.columns.size() + 1) + "}");
                else
                    bw.write("\\begin{tabular}{|" + repeatString(" c |", opt.vbreak + 1) + "|"
                                    + repeatString(" c |", opt.columns.size() - opt.vbreak) + "}");
                bw.newLine();
                bw.write("  \\hline");
                bw.newLine();
                bw.write("  " + opt.label);
                for(String S[] : opt.columns)
                    bw.write(" & " + S[2]);
                bw.write(" \\\\ \\hline");
                bw.newLine();
                for(String A[] : opt.rows){
                    bw.write("  " + A[2]);
                    for(String b[] : opt.columns) bw.write(" & \\shortstack{" + co.latex(A[0], b[0]) + "}");
                    bw.write(" \\\\ \\hline");
                    bw.newLine();
                }
                bw.write("\\end{tabular}");
                bw.newLine();
                bw.close();
            } catch(java.io.IOException e){
                System.out.println(opt.outname + ".tex appears to be locked.\n");
                System.exit(9);
            }
        }
    
        if(opt.html){
            try{
                java.io.BufferedWriter bw = new java.io.BufferedWriter(new java.io.FileWriter(opt.outname + opt.title + ".html"));
                bw.write("<table border='1' align='center'>");
                bw.newLine();
                bw.write("<tbody>");
                bw.newLine();
                bw.write("  <tr align='center'> <td>" + opt.label + "</td>");
                for(String S[] : opt.columns)
                    bw.write(" <td>" + S[1] + "</td>");
                bw.write("</tr>");
                bw.newLine();
                for(String A[] : opt.rows){
                    bw.write("    <tr align='center'> <td>" + A[1] + "</td>");
                    for(String b[] : opt.columns) bw.write(" <td>" + co.html(A[0],b[0]) + "</td>");
                    bw.write("</tr>");
                    bw.newLine();
                }
                bw.write("  </tbody>");
                bw.newLine();
                bw.write("</table>");
                bw.newLine();
                bw.close();
            } catch(java.io.IOException e){
                System.out.println(opt.outname + ".html appears to be locked.\n");
                System.exit(9);
            }
        }
    }

    /*  String manipulation helper function
    Usage:  o = repeatString(s, p)
    Post:   o is s concatenated p times
    */
    private String repeatString(String s, int p){
        String o = "";
        while(p-- > 0) o += s;
        return o;
    }
    
    /*  external toString()
    Usage:  s = arrayToString(a)
    Post:   s is the elements.toString() of array a in order seperated by a space
    */
    private <E extends Object> String arrayToString(E[] a){
        String ret = "";
        for(E s : a)
            ret += " " + s.toString();
        return ret;
    }
    
    /*  external toString()
    Usage:  str = setToString(a, s)
    Post:   str is the elements.toString() of array a in order seperated by s
    */
    private <E extends Object>String setToString(java.util.Set<E> set, String seperator){
        String o = "";
        for(E s : set)
            if(o.equals("")) o += s.toString();
            else o += seperator + s.toString();
        return o;
    }
    
    /*  nonspecific table element method
    callObject implements a method call, which is used to fill in individual spaces of a table,
    callObject should be extended and overwritten for each type of table
    */
    public class callObject{
        public String html(String A, String b){
            return "";
        }
        
        public String latex(String A, String b){
            return "";
        }
    }
    
    /*  specific table element method 
    
    */
    public class firstCO extends callObject{
        public String html(String A, String b){
            return setToString(PTG.escapeHtml(first(A),empty),"<br>");
        }
        
        public String latex(String A, String b){
            return setToString(PTG.escapeLatex(first(A),empty, false)," \\\\ ");
        }
    }
    
    /*  specific table element method 
    
    */
    public class followCO extends callObject{
        public String html(String A, String b){
            return setToString(PTG.escapeHtml(follow(A),empty), "<br>");
        }
        
        public String latex(String A, String b){
            return setToString(PTG.escapeLatex(follow(A),empty, false), " \\\\ ");
        }
    }
    
    /*  specific table element method 
    
    */
    public class LL1CO extends callObject{
        public String html(String A, String b){
            TreeSet<String[]> reductions = LL1(A, b);
            String s = "";
            if(!reductions.isEmpty()){
                for(String[] reduction : reductions){
                    if(!s.equals("")){
                        s += "<br>";
                        if(noConflict){
                            noConflict = false;
                            System.err.println("LL(1) conflict detected. Could be others.");
                        }
                    }
                    reduction = PTG.escapeHtml(reduction,empty);
                    for(String r : reduction) s += r + " ";
                }
            }
            return s;
        }
        
        public String latex(String A, String b){
            TreeSet<String[]> reductions = LL1(A, b);
            String s = "";
            if(!reductions.isEmpty()){
                for(String[] reduction : reductions){
                    if(!s.equals("")){
                        s += " \\\\ ";
                        if(noConflict){
                            noConflict = false;
                            System.err.println("LL(1) conflict detected. Could be others.");
                        }
                    }
                    reduction = PTG.escapeLatex(reduction,empty, false);
                    for(String r : reduction) s += r + " ";
                }
            }
            return s;
        }
    }
    
    /*  specific table element method 
    
    */
    public class SLR1CO extends callObject{
        StateMachine M;
        
        public SLR1CO(StateMachine M){
            this.M = M;
        }
        
        public String html(String A, String b){
            return SLR1(M, Integer.parseInt(A), b)[0];
        }
        
        public String latex(String A, String b){
            return SLR1(M, Integer.parseInt(A), b)[1];
        }
    }
    
    /*  specific table element method 
    
    */
    public class LALR1CO extends callObject{
        StateMachine M;
        
        public LALR1CO(StateMachine M){
            this.M = M;
        }
        
        public String html(String A, String b){
            return LALR1(M, Integer.parseInt(A), b)[0];
        }
        
        public String latex(String A, String b){
            return LALR1(M, Integer.parseInt(A), b)[1];
        }
    }
    
    public class LR1CO extends callObject{
        StateMachine M;
        
        public LR1CO(StateMachine M){
            this.M = M;
        }
        
        public String html(String A, String b){
            return LR1(M, Integer.parseInt(A), b)[0];
        }
        
        public String latex(String A, String b){
            return LR1(M, Integer.parseInt(A), b)[1];
        }
    }
}
